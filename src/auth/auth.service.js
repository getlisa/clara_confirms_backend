/**
 * Auth Service
 * Handles user authentication, token generation, and password management.
 */

const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const db = require("../db");
const config = require("../config");
const logger = require("../utils/logger");

const SALT_ROUNDS = 12;

/**
 * Generate a JWT access token
 * @param {Object} payload - { userId, email, companyId, role }
 * @returns {string} JWT token
 */
function generateAccessToken(payload) {
  return jwt.sign(
    {
      userId: payload.userId,
      email: payload.email,
      companyId: payload.companyId,
      role: payload.role,
      type: "access",
    },
    config.jwt.secret,
    { expiresIn: config.jwt.expiresIn }
  );
}

/**
 * Generate a JWT refresh token
 * @param {Object} payload - { userId, email, companyId, role }
 * @returns {string} JWT token
 */
function generateRefreshToken(payload) {
  return jwt.sign(
    {
      userId: payload.userId,
      email: payload.email,
      companyId: payload.companyId,
      role: payload.role,
      type: "refresh",
    },
    config.jwt.secret,
    { expiresIn: config.jwt.refreshExpiresIn }
  );
}

/**
 * Hash a password using bcrypt
 * @param {string} password - Plain text password
 * @returns {Promise<string>} Hashed password
 */
async function hashPassword(password) {
  return bcrypt.hash(password, SALT_ROUNDS);
}

/**
 * Compare a password with a hash
 * @param {string} password - Plain text password
 * @param {string} hash - Bcrypt hash
 * @returns {Promise<boolean>} Match result
 */
async function comparePassword(password, hash) {
  return bcrypt.compare(password, hash);
}

function fullName(row) {
  return [row.first_name, row.last_name].filter(Boolean).join(" ").trim() || "";
}

/**
 * Register a new user and company
 * @param {Object} data - { email, password, name, companyName }
 * @returns {Promise<{user: Object, token: string, refreshToken: string}>}
 */
async function register({ email, password, name, companyName }) {
  const nameStr = String(name || "").trim();
  const first = nameStr.split(/\s+/)[0] || "";
  const last = nameStr.includes(" ") ? nameStr.replace(/^\s*\S+\s*/, "").trim() : "";

  return db.transaction(async (client) => {
    // Check if email already exists
    const existingUser = await client.query(
      "SELECT id FROM users WHERE email = $1",
      [email.toLowerCase()]
    );
    if (existingUser.rows.length > 0) {
      const error = new Error("Email already registered");
      error.status = 409;
      throw error;
    }

    // Create company (ID auto-generated by database)
    const companyResult = await client.query(
      `INSERT INTO companies (name) 
       VALUES ($1) 
       RETURNING id, name, created_at`,
      [companyName]
    );
    const company = companyResult.rows[0];

    // Hash password
    const passwordHash = await hashPassword(password);

    // Create user (ID auto-generated by database)
    const userResult = await client.query(
      `INSERT INTO users (company_id, email, first_name, last_name, password_hash, role, active) 
       VALUES ($1, $2, $3, $4, $5, $6, $7) 
       RETURNING id, company_id, email, first_name, last_name, role, active, created_at`,
      [company.id, email.toLowerCase(), first, last, passwordHash, "admin", true]
    );
    const user = userResult.rows[0];

    // Generate tokens
    const tokenPayload = {
      userId: user.id,
      email: user.email,
      companyId: user.company_id,
      role: user.role,
    };
    const token = generateAccessToken(tokenPayload);
    const refreshToken = generateRefreshToken(tokenPayload);

    logger.info("User registered successfully", { userId: user.id, companyId: company.id });

    return {
      user: {
        id: user.id,
        email: user.email,
        name: fullName(user),
        first_name: user.first_name,
        last_name: user.last_name,
        role: user.role,
        company_id: user.company_id,
        company_name: company.name,
      },
      token,
      refreshToken,
    };
  });
}

/**
 * Login a user with email and password
 * @param {string} email - User email
 * @param {string} password - User password
 * @returns {Promise<{user: Object, token: string, refreshToken: string}>}
 */
async function login(email, password) {
  // Fetch user with company details
  const result = await db.query(
    `SELECT u.id, u.company_id, u.email, u.first_name, u.last_name, u.password_hash, u.role, u.active,
            c.name as company_name
     FROM users u
     JOIN companies c ON u.company_id = c.id
     WHERE u.email = $1`,
    [email.toLowerCase()]
  );

  if (result.rows.length === 0) {
    const error = new Error("Invalid email or password");
    error.status = 401;
    throw error;
  }

  const user = result.rows[0];

  // Check if user is active
  if (!user.active) {
    const error = new Error("Account is deactivated");
    error.status = 403;
    throw error;
  }

  // Verify password
  const isValid = await comparePassword(password, user.password_hash);
  if (!isValid) {
    const error = new Error("Invalid email or password");
    error.status = 401;
    throw error;
  }

  // Update last_login
  await db.query(
    "UPDATE users SET last_login = NOW() WHERE id = $1",
    [user.id]
  );

  // Generate tokens
  const tokenPayload = {
    userId: user.id,
    email: user.email,
    companyId: user.company_id,
    role: user.role,
  };
  const token = generateAccessToken(tokenPayload);
  const refreshToken = generateRefreshToken(tokenPayload);

  logger.info("User logged in", { userId: user.id });

  return {
    user: {
      id: user.id,
      email: user.email,
      name: fullName(user),
      first_name: user.first_name,
      last_name: user.last_name,
      role: user.role,
      company_id: user.company_id,
      company_name: user.company_name,
    },
    token,
    refreshToken,
  };
}

/**
 * Refresh tokens using a refresh token
 * @param {string} refreshToken - JWT refresh token
 * @returns {Promise<{token: string, refreshToken: string}>}
 */
async function refresh(refreshToken) {
  let decoded;
  try {
    decoded = jwt.verify(refreshToken, config.jwt.secret);
  } catch (err) {
    const error = new Error("Invalid or expired refresh token");
    error.status = 401;
    throw error;
  }

  if (decoded.type !== "refresh") {
    const error = new Error("Invalid token type");
    error.status = 401;
    throw error;
  }

  // Verify user still exists and is active
  const result = await db.query(
    `SELECT u.id, u.company_id, u.email, u.first_name, u.last_name, u.role, u.active,
            c.name as company_name
     FROM users u
     JOIN companies c ON u.company_id = c.id
     WHERE u.id = $1`,
    [decoded.userId]
  );

  if (result.rows.length === 0) {
    const error = new Error("User not found");
    error.status = 401;
    throw error;
  }

  const user = result.rows[0];

  if (!user.active) {
    const error = new Error("Account is deactivated");
    error.status = 403;
    throw error;
  }

  // Generate new tokens
  const tokenPayload = {
    userId: user.id,
    email: user.email,
    companyId: user.company_id,
    role: user.role,
  };
  const newToken = generateAccessToken(tokenPayload);
  const newRefreshToken = generateRefreshToken(tokenPayload);

  return {
    token: newToken,
    refreshToken: newRefreshToken,
    user: {
      id: user.id,
      email: user.email,
      name: fullName(user),
      first_name: user.first_name,
      last_name: user.last_name,
      role: user.role,
      company_id: user.company_id,
      company_name: user.company_name,
    },
  };
}

/**
 * Change user password
 * @param {string} userId - User ID
 * @param {string} currentPassword - Current password
 * @param {string} newPassword - New password
 * @returns {Promise<void>}
 */
async function changePassword(userId, currentPassword, newPassword) {
  // Fetch user
  const result = await db.query(
    "SELECT id, password_hash FROM users WHERE id = $1",
    [userId]
  );

  if (result.rows.length === 0) {
    const error = new Error("User not found");
    error.status = 404;
    throw error;
  }

  const user = result.rows[0];

  // Verify current password
  const isValid = await comparePassword(currentPassword, user.password_hash);
  if (!isValid) {
    const error = new Error("Current password is incorrect");
    error.status = 401;
    throw error;
  }

  // Hash new password
  const newHash = await hashPassword(newPassword);

  // Update password
  await db.query(
    "UPDATE users SET password_hash = $1, updated_at = NOW() WHERE id = $2",
    [newHash, userId]
  );

  logger.info("Password changed", { userId });
}

/**
 * Get user by ID with company details
 * @param {string} userId - User ID
 * @returns {Promise<Object|null>}
 */
async function getUserById(userId) {
  const result = await db.query(
    `SELECT u.id, u.company_id, u.email, u.first_name, u.last_name, u.role, u.active, u.last_login,
            c.name as company_name
     FROM users u
     JOIN companies c ON u.company_id = c.id
     WHERE u.id = $1`,
    [userId]
  );

  if (result.rows.length === 0) {
    return null;
  }

  const user = result.rows[0];
  return {
    id: user.id,
    email: user.email,
    name: fullName(user),
    first_name: user.first_name,
    last_name: user.last_name,
    role: user.role,
    active: user.active,
    last_login: user.last_login,
    company_id: user.company_id,
    company_name: user.company_name,
  };
}

/**
 * Get user by email
 * @param {string} email - User email
 * @returns {Promise<Object|null>}
 */
async function getUserByEmail(email) {
  const result = await db.query(
    `SELECT u.id, u.company_id, u.email, u.first_name, u.last_name, u.role, u.active, u.supabase_id,
            c.name as company_name
     FROM users u
     JOIN companies c ON u.company_id = c.id
     WHERE u.email = $1`,
    [email.toLowerCase()]
  );

  if (result.rows.length === 0) {
    return null;
  }
  const row = result.rows[0];
  row.name = fullName(row);
  return row;
}

/**
 * Get user by Supabase ID
 * @param {string} supabaseId - Supabase user ID (sub claim)
 * @returns {Promise<Object|null>}
 */
async function getUserBySupabaseId(supabaseId) {
  const result = await db.query(
    `SELECT u.id, u.company_id, u.email, u.first_name, u.last_name, u.role, u.active,
            c.name as company_name
     FROM users u
     JOIN companies c ON u.company_id = c.id
     WHERE u.supabase_id = $1`,
    [supabaseId]
  );

  if (result.rows.length === 0) {
    return null;
  }
  const row = result.rows[0];
  row.name = fullName(row);
  return row;
}

/**
 * Update user profile (first_name, last_name, email)
 * @param {string} userId - User ID
 * @param {Object} payload - { first_name?, last_name?, email? }
 * @returns {Promise<Object>} Updated user (same shape as getUserById)
 */
async function updateProfile(userId, { first_name: firstName, last_name: lastName, email }) {
  if (firstName === undefined && lastName === undefined && email === undefined) {
    return getUserById(userId);
  }
  const updates = [];
  const values = [];
  let i = 1;
  if (firstName !== undefined) {
    updates.push(`first_name = $${i++}`);
    values.push(String(firstName).trim());
  }
  if (lastName !== undefined) {
    updates.push(`last_name = $${i++}`);
    values.push(String(lastName).trim());
  }
  if (email !== undefined) {
    const normalized = String(email).trim().toLowerCase();
    const existing = await db.query(
      "SELECT id FROM users WHERE email = $1 AND id != $2",
      [normalized, userId]
    );
    if (existing.rows.length > 0) {
      const err = new Error("Email is already in use");
      err.status = 409;
      throw err;
    }
    updates.push(`email = $${i++}`);
    values.push(normalized);
  }
  if (updates.length === 0) {
    return getUserById(userId);
  }
  values.push(userId);
  await db.query(
    `UPDATE users SET ${updates.join(", ")}, updated_at = NOW() WHERE id = $${i}`,
    values
  );
  return getUserById(userId);
}

/**
 * Update user's Supabase ID
 * @param {string} userId - User ID
 * @param {string} supabaseId - Supabase user ID
 * @returns {Promise<void>}
 */
async function updateSupabaseId(userId, supabaseId) {
  await db.query(
    "UPDATE users SET supabase_id = $1, updated_at = NOW() WHERE id = $2",
    [supabaseId, userId]
  );
}

/**
 * Update user's password hash by email
 * @param {string} email - User email
 * @param {string} newPassword - New plain text password
 * @returns {Promise<void>}
 */
async function updatePasswordByEmail(email, newPassword) {
  const newHash = await hashPassword(newPassword);
  await db.query(
    "UPDATE users SET password_hash = $1, updated_at = NOW() WHERE email = $2",
    [newHash, email.toLowerCase()]
  );
  logger.info("Password updated via reset", { email: email.substring(0, 3) + "***" });
}

module.exports = {
  register,
  login,
  refresh,
  changePassword,
  getUserById,
  getUserByEmail,
  getUserBySupabaseId,
  updateProfile,
  updateSupabaseId,
  updatePasswordByEmail,
  generateAccessToken,
  generateRefreshToken,
  hashPassword,
  comparePassword,
};
